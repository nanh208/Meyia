// index.js ‚Äî Meyia all-in-one (stable) ‚Äî Music (YouTube Music) enabled
require("dotenv").config();

const fs = require("fs");
const path = require("path");
const ms = require("ms");

const {
  Client,
  Events,
  GatewayIntentBits,
  ApplicationCommandOptionType,
  EmbedBuilder,
  PermissionFlagsBits
} = require("discord.js");

// ---------- Music related ----------
const { Player, QueryType } = require("discord-player");
const playdl = require("play-dl"); // used by discord-player as extractor back-end
// ------------------------------------

const { GiveawaysManager } = require("discord-giveaways");

// -------- CLIENT INIT -------- //
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildVoiceStates // <-- c·∫ßn cho voice
  ]
});

// -------- CONFIG -------- //
const OWNER_ID = process.env.OWNER_ID || "1409222785154416651";
const MAIN_COLOR = "#CA50DC";

// -------- ACTIVITY CONFIG FILE -------- //
const activityPath = path.join(__dirname, "config", "activity.json");
if (!fs.existsSync(path.dirname(activityPath))) fs.mkdirSync(path.dirname(activityPath), { recursive: true });
if (!fs.existsSync(activityPath)) fs.writeFileSync(activityPath, "{}");
let activityConfig = JSON.parse(fs.readFileSync(activityPath, "utf8"));
function saveActivityConfig() { fs.writeFileSync(activityPath, JSON.stringify(activityConfig, null, 2)); }
function logActivity(guildId, msg) {
  const cfg = activityConfig[guildId];
  if (!cfg || !cfg.enabled || !cfg.channelId) return;
  const ch = client.channels.cache.get(cfg.channelId);
  if (ch) ch.send(msg).catch(() => {});
}

function hasAdminPermission(i) {
  return (
    i?.member?.permissions?.has(PermissionFlagsBits.Administrator) ||
    i?.user?.id === OWNER_ID ||
    i?.member?.permissions?.has(PermissionFlagsBits.ManageGuild)
  );
}

// -------- GIVEAWAY MANAGER (KEEP ORIGINAL BEHAVIOR) -------- //
const manager = new GiveawaysManager(client, {
  storage: "./giveaways.json",
  default: {
    botsCanWin: false,
    embedColor: MAIN_COLOR,
    embedColorEnd: "#000000",
    reaction: "<a:1261960933270618192:1433286685189341204>",
    winnerCount: 1
  }
});
client.giveawaysManager = manager;

// -------- SETUP play-dl (YouTube Music cookie) -------- //
// If you selected option 3 (YouTube Music), put cookie into .env as YOUTUBE_COOKIE
if (process.env.YOUTUBE_COOKIE) {
  try {
    // play-dl accepts cookie via playdl.setCookies or environment; set manually:
    playdl.setToken({ ytmusic: process.env.YOUTUBE_COOKIE });
  } catch (err) {
    console.warn("‚ö†Ô∏è play-dl cookie setup warning:", err?.message || err);
  }
}

// -------- PLAYER INIT (single instance) -------- //
client.player = new Player(client, {
  ytdlOptions: {
    quality: "highestaudio",
    highWaterMark: 1 << 25
  }
});

// Optional: attach event listeners for debugging (you can remove or keep)
client.player.on("error", (queue, error) => {
  console.error(`Player Error in guild ${queue.guild.id}:`, error);
});
client.player.on("playerStart", (queue, track) => {
  // send simple now playing embed to metadata channel if provided
  if (queue.metadata?.channel) {
    try {
      queue.metadata.channel.send({ content: `üé∂ ƒêang ph√°t: **${track.title}** ‚Äî y√™u c·∫ßu b·ªüi <@${track.requestedBy?.id || "?"}>` }).catch(() => {});
    } catch (e) {}
  }
});
client.player.on("playerDisconnect", (queue) => {
  // cleanup if bot was disconnected
  if (queue.metadata?.channel) {
    try { queue.metadata.channel.send("üìõ Bot ƒë√£ r·ªùi voice, queue ƒë√£ b·ªã hu·ª∑.").catch(()=>{}); } catch(e) {}
  }
});

// -------- READY & REGISTER SLASH COMMANDS -------- //
client.once(Events.ClientReady, async () => {
  console.log(`‚úÖ Bot MEYIA ƒë√£ s·∫µn s√†ng (${client.user.tag})`);

  // Commands array (every option has description to avoid Invalid Form Body)
  const commands = [
    { name: "help", description: "Xem danh s√°ch l·ªánh c·ªßa bot" },
    { name: "status", description: "Xem tr·∫°ng th√°i bot" },
    {
      name: "giveaway",
      description: "T·∫°o giveaway üéâ",
      options: [
        { name: "time", description: "Th·ªùi gian (v√≠ d·ª•: 1m, 1h, 1d)", type: ApplicationCommandOptionType.String, required: true },
        { name: "winners", description: "S·ªë ng∆∞·ªùi th·∫Øng", type: ApplicationCommandOptionType.Integer, required: true },
        { name: "prize", description: "Ph·∫ßn th∆∞·ªüng", type: ApplicationCommandOptionType.String, required: true }
      ]
    },
    { name: "ping", description: "Ki·ªÉm tra ƒë·ªô tr·ªÖ" },
    { name: "8ball", description: "Qu·∫£ c·∫ßu ti√™n tri" },
    { name: "rps", description: "O·∫≥n t√π t√¨" },
    { name: "love", description: "ƒê·ªô h·ª£p ƒë√¥i" },
    { name: "mood", description: "T√¢m tr·∫°ng Meyia" },
    { name: "quote", description: "Tr√≠ch d·∫´n ng·∫´u nhi√™n" },
    { name: "say", description: "Cho bot n√≥i l·∫°i n·ªôi dung b·∫°n nh·∫≠p", options: [{ name: "text", description: "N·ªôi dung bot s·∫Ω n√≥i", type: ApplicationCommandOptionType.String, required: true }] },
    { name: "avatar", description: "Xem avatar c·ªßa user (n·∫øu kh√¥ng ch·ªçn th√¨ l·∫•y b·∫°n)", options: [{ name: "user", description: "Ng∆∞·ªùi c·∫ßn xem avatar", type: ApplicationCommandOptionType.User, required: false }] },
    { name: "xoachat", description: "X√≥a tin nh·∫Øn (1-99)", options: [{ name: "count", description: "S·ªë l∆∞·ª£ng tin nh·∫Øn mu·ªën x√≥a (1-99)", type: ApplicationCommandOptionType.Integer, required: true }] },
    { name: "info", description: "Th√¥ng tin bot" },

    // ---------- Music slash commands ----------
    // /play nh·∫≠n 2 tu·ª≥ ch·ªçn: link (URL) v√† ten (t√™n b√†i/playlist). Kh√¥ng b·∫Øt bu·ªôc tr√™n discord, ki·ªÉm tra trong handler (√≠t nh·∫•t 1 tu·ª≥ ch·ªçn).
    { name: "play", description: "Ph√°t nh·∫°c (link ho·∫∑c t√™n)", options: [
      { name: "link", description: "URL b√†i/playlist (n·∫øu c√≥)", type: ApplicationCommandOptionType.String, required: false },
      { name: "ten", description: "T√™n b√†i/playlist (n·∫øu kh√¥ng d√πng link)", type: ApplicationCommandOptionType.String, required: false },
      { name: "query", description: "Legacy: t√™n b√†i / link / playlist", type: ApplicationCommandOptionType.String, required: false }
    ] },
    { name: "stop", description: "D·ª´ng nh·∫°c v√† r·ªùi voice" },
    { name: "skip", description: "B·ªè qua b√†i ƒëang ph√°t" },
    { name: "pause", description: "T·∫°m d·ª´ng ph√°t" },
    { name: "resume", description: "Ti·∫øp t·ª•c ph√°t" },
    { name: "queue", description: "Xem queue hi·ªán t·∫°i" },
    { name: "volume", description: "ƒê·∫∑t √¢m l∆∞·ª£ng (1-200)", options: [{ name: "value", description: "S·ªë (1-200)", type: ApplicationCommandOptionType.Integer, required: true }] },

    // activity commands placeholder (admin)
    {
      name: "activity",
      description: "Qu·∫£n l√Ω log ho·∫°t ƒë·ªông (ch·ªâ admin)",
      options: [
        {
          name: "setup",
          description: "Ch·ªçn k√™nh log",
          type: ApplicationCommandOptionType.Subcommand,
          options: [{ name: "channel", description: "K√™nh log (ch·ªçn)", type: ApplicationCommandOptionType.Channel, required: true }]
        },
        { name: "enable", description: "B·∫≠t log ho·∫°t ƒë·ªông", type: ApplicationCommandOptionType.Subcommand },
        { name: "disable", description: "T·∫Øt log ho·∫°t ƒë·ªông", type: ApplicationCommandOptionType.Subcommand }
      ]
    }
  ];

  try {
    await client.application.commands.set(commands);
    console.log("‚úÖ Slash commands ƒë√£ ƒëƒÉng k√Ω.");
  } catch (err) {
    console.error("‚ùå L·ªói khi ƒëƒÉng k√Ω slash commands:", err);
  }
});

// -------- INTERACTIONS HANDLER (includes music) -------- //
client.on(Events.InteractionCreate, async (interaction) => {
  if (!interaction.isChatInputCommand()) return;
  const cmd = interaction.commandName;

  // ---------- GIVEAWAY (KEEP ORIGINAL FUNCTIONALITY) ----------
  if (cmd === "giveaway") {
    try {
      const prize = interaction.options.getString("prize");
      const duration = ms(interaction.options.getString("time"));
      const winnerCount = interaction.options.getInteger("winners");
      if (!duration) return interaction.reply({ content: "‚ö†Ô∏è Th·ªùi gian kh√¥ng h·ª£p l·ªá!", ephemeral: true });

      const endTime = Date.now() + duration;
      const giveawayId = Math.floor(Math.random() * 999999999);

      const embed = new EmbedBuilder()
        .setColor(MAIN_COLOR)
        .setTitle(`<a:1255341894687260775:1433317867293642858> G I V E A W A Y <a:1255341894687260775:1433317867293642858>`)
        .setDescription(
          `üéÅ **Ph·∫ßn th∆∞·ªüng:** ${prize}\n\n` +
          `<a:1255340646248616061:1433317989406605383> Nh·∫•n emoji b√™n d∆∞·ªõi ƒë·ªÉ tham gia!\n\n` +
          `üëë **T·ªï ch·ª©c b·ªüi:** ${interaction.user}\n` +
          `üèÜ **S·ªë l∆∞·ª£ng gi·∫£i:** ${winnerCount}\n` +
          `‚è∞ **K·∫øt th√∫c:** <t:${Math.floor(endTime / 1000)}:R>`
        )
        .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))
        .setImage(interaction.client.user.displayAvatarURL({ dynamic: true, size: 512 }))
        .setFooter({ text: `üìõ M√£ giveaway: ${giveawayId}` });

      const msg = await interaction.channel.send({ embeds: [embed] });
      await msg.react("<a:1261960933270618192:1433286685189341204>");

      const participants = new Set();
      const collector = msg.createReactionCollector({
        filter: (reaction, u) => {
          try {
            return reaction.emoji.id === "1261960933270618192" && !u.bot;
          } catch (e) {
            return false;
          }
        },
        time: duration
      });

      collector.on("collect", (_, u) => participants.add(u.id));
      collector.on("end", async () => {
        let winners = [];
        if (participants.size === 0) {
          winners = [];
        } else {
          const arr = Array.from(participants);
          for (let i = 0; i < winnerCount && arr.length > 0; i++) {
            const idx = Math.floor(Math.random() * arr.length);
            winners.push(arr.splice(idx, 1)[0]);
          }
        }

        const endEmbed = new EmbedBuilder()
          .setColor(MAIN_COLOR)
          .setTitle(`<a:1255341894687260775:1433317867293642858> GIVEAWAY K·∫æT TH√öC <a:1255340646248616061:1433286685189341204>`)
          .setDescription(
            `üéÅ **Ph·∫ßn th∆∞·ªüng:** ${prize}\n\n` +
            `${winners.length ? `üèÜ **Ng∆∞·ªùi chi·∫øn th·∫Øng:** ${winners.map(id => `<@${id}>`).join(", ")}` : "‚ùå Kh√¥ng c√≥ ai tham gia!"}\n\n` +
            `üëë **Ng∆∞·ªùi t·ªï ch·ª©c:** ${interaction.user}\nüìõ **M√£ giveaway:** ${giveawayId}`
          )
          .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))
          .setImage(interaction.client.user.displayAvatarURL({ dynamic: true, size: 512 }));

        await msg.edit({ embeds: [endEmbed] });
        if (winners.length > 0) interaction.channel.send(`üéä Ch√∫c m·ª´ng ${winners.map(id => `<@${id}>`).join(", ")} ƒë√£ th·∫Øng **${prize}**!`);
      });

      return interaction.reply({ content: "‚úÖ Giveaway ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!", ephemeral: true });
    } catch (err) {
      console.error("Giveaway error:", err);
      return interaction.reply({ content: "‚ùå L·ªói khi t·∫°o giveaway.", ephemeral: true });
    }
  }

  // ---------- MUSIC COMMANDS ----------
  if (cmd === "play") {
    const query = interaction.options.getString("query");
    const memberVoice = interaction.member?.voice?.channel;
    if (!memberVoice) return interaction.reply({ content: "‚ùó B·∫°n ph·∫£i v√†o k√™nh tho·∫°i tr∆∞·ªõc!", ephemeral: true });

    await interaction.deferReply();

    try {
      // prefer QueryType.AUTO to allow play-dl to resolve YouTube Music / YT
      const search = await client.player.search(query, {
        requestedBy: interaction.user,
        searchEngine: QueryType.AUTO
      });

      if (!search || !search.tracks.length) return interaction.editReply("‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t!");

      const queue = await client.player.createQueue(interaction.guild, {
        metadata: { channel: interaction.channel }
      });

      try {
        if (!queue.connection) await queue.connect(memberVoice);
      } catch (err) {
        client.player.deleteQueue(interaction.guild.id);
        return interaction.editReply("‚ö†Ô∏è Bot kh√¥ng th·ªÉ v√†o voice (ki·ªÉm tra quy·ªÅn Connect).");
      }

      // if playlist -> add all, else add first track
      if (search.playlist) {
        queue.addTracks(search.tracks);
      } else {
        queue.addTrack(search.tracks[0]);
      }

      if (!queue.playing) await queue.play();

      const track = queue.current;
      return interaction.editReply(`üé∂ ƒêang ph√°t: **${track.title}** ‚Äî Y√™u c·∫ßu b·ªüi ${interaction.user}`);
    } catch (err) {
      console.error("Play command error:", err);
      return interaction.editReply("‚ùå L·ªói khi ph√°t nh·∫°c.");
    }
  }

  if (cmd === "stop") {
    try {
      const queue = client.player.getQueue(interaction.guild.id);
      if (!queue) return interaction.reply({ content: "‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t!", ephemeral: true });
      queue.destroy();
      return interaction.reply({ content: "‚õî ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi voice." });
    } catch (err) {
      console.error("Stop error:", err);
      return interaction.reply({ content: "‚ùå L·ªói khi d·ª´ng nh·∫°c.", ephemeral: true });
    }
  }

  if (cmd === "skip") {
    try {
      const queue = client.player.getQueue(interaction.guild.id);
      if (!queue || !queue.playing) return interaction.reply({ content: "‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t!", ephemeral: true });
      const current = queue.current;
      const ok = await queue.skip();
      if (ok) return interaction.reply({ content: `‚è≠Ô∏è ƒê√£ b·ªè qua: **${current.title}**` });
      return interaction.reply({ content: "‚ùå Kh√¥ng th·ªÉ b·ªè qua b√†i.", ephemeral: true });
    } catch (err) {
      console.error("Skip error:", err);
      return interaction.reply({ content: "‚ùå L·ªói khi skip.", ephemeral: true });
    }
  }

  if (cmd === "pause") {
    try {
      const queue = client.player.getQueue(interaction.guild.id);
      if (!queue || !queue.playing) return interaction.reply({ content: "‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t!", ephemeral: true });
      queue.setPaused(true);
      return interaction.reply({ content: "‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng." });
    } catch (err) {
      console.error("Pause error:", err);
      return interaction.reply({ content: "‚ùå L·ªói khi pause.", ephemeral: true });
    }
  }

  if (cmd === "resume") {
    try {
      const queue = client.player.getQueue(interaction.guild.id);
      if (!queue) return interaction.reply({ content: "‚ùå Kh√¥ng c√≥ queue.", ephemeral: true });
      queue.setPaused(false);
      return interaction.reply({ content: "‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t." });
    } catch (err) {
      console.error("Resume error:", err);
      return interaction.reply({ content: "‚ùå L·ªói khi resume.", ephemeral: true });
    }
  }

  if (cmd === "queue") {
    try {
      const queue = client.player.getQueue(interaction.guild.id);
      if (!queue || !queue.playing) return interaction.reply({ content: "üì≠ Queue ƒëang tr·ªëng!", ephemeral: true });

      const current = queue.current;
      const tracks = queue.tracks.slice(0, 10);
      const list = tracks.length ? tracks.map((t,i) => `**${i+1}.** ${t.title} ‚Äî <@${t.requestedBy?.id||"?"}>`).join("\n") : "Kh√¥ng c√≥ b√†i n√†o trong queue.";

      const embed = new EmbedBuilder()
        .setColor(MAIN_COLOR)
        .setTitle("üé∂ Danh s√°ch ph√°t")
        .setDescription(`**ƒêang ph√°t:** ${current.title}\n\n**Ti·∫øp theo:**\n${list}`)
        .setFooter({ text: `T·ªïng b√†i trong queue: ${queue.tracks.length + (queue.current ? 1 : 0)}` });

      return interaction.reply({ embeds: [embed] });
    } catch (err) {
      console.error("Queue error:", err);
      return interaction.reply({ content: "‚ùå L·ªói khi l·∫•y queue.", ephemeral: true });
    }
  }

  if (cmd === "volume") {
    try {
      const value = interaction.options.getInteger("value");
      const queue = client.player.getQueue(interaction.guild.id);
      if (!queue) return interaction.reply({ content: "‚ùå Kh√¥ng c√≥ nh·∫°c ƒëang ph√°t!", ephemeral: true });
      if (!value || value < 1 || value > 200) return interaction.reply({ content: "üîä Nh·∫≠p √¢m l∆∞·ª£ng h·ª£p l·ªá (1 - 200).", ephemeral: true });

      queue.setVolume(value);
      return interaction.reply({ content: `‚úÖ √Çm l∆∞·ª£ng ƒë√£ ƒë·∫∑t th√†nh **${value}%**` });
    } catch (err) {
      console.error("Volume error:", err);
      return interaction.reply({ content: "‚ùå L·ªói khi ƒë·∫∑t volume.", ephemeral: true });
    }
  }

  // ---------- UTIL & FUN (unchanged) ----------
  if (cmd === "ping") return interaction.reply(`üèì Pong! ƒê·ªô tr·ªÖ: ${client.ws.ping}ms`);
  if (cmd === "love") return interaction.reply(`üíû M·ª©c ƒë·ªô h·ª£p ƒë√¥i: ${Math.floor(Math.random() * 101)}%`);
  if (cmd === "rps") return interaction.reply(["‚úä", "üñêÔ∏è", "‚úåÔ∏è"][Math.floor(Math.random() * 3)]);
  if (cmd === "8ball") return interaction.reply(["C√≥", "Kh√¥ng", "C√≥ th·ªÉ", "H·ªèi l·∫°i sau nh√©~"][Math.floor(Math.random() * 4)]);
  if (cmd === "mood") return interaction.reply(["üòä Vui v·∫ª", "üò¥ M·ªát m·ªèi", "ü•∞ H·∫°nh ph√∫c", "ü§î Tr·∫ßm t∆∞"][Math.floor(Math.random() * 4)]);
  if (cmd === "quote") return interaction.reply(["‚ú® S·ªëng l√† ph·∫£i vui!", "üí´ B·∫°n l√†m ƒë∆∞·ª£c!", "üå∏ C·ª© ti·∫øn l√™n n√†o!"][Math.floor(Math.random() * 3)]);

  if (cmd === "say") {
    const text = interaction.options.getString("text");
    if (!text) return interaction.reply({ content: "‚ö†Ô∏è B·∫°n ch∆∞a nh·∫≠p n·ªôi dung.", ephemeral: true });
    return interaction.reply({ content: text });
  }

  if (cmd === "avatar") {
    const user = interaction.options.getUser("user") || interaction.user;
    const embed = new EmbedBuilder()
      .setColor(MAIN_COLOR)
      .setTitle(`üñº Avatar c·ªßa ${user.username}`)
      .setImage(user.displayAvatarURL({ dynamic: true, size: 512 }));
    return interaction.reply({ embeds: [embed], ephemeral: true });
  }

  if (cmd === "xoachat") {
    if (!hasAdminPermission(interaction)) return interaction.reply({ content: "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh n√†y!", ephemeral: true });
    const count = interaction.options.getInteger("count");
    if (!count || count < 1 || count > 99) return interaction.reply({ content: "‚ö†Ô∏è S·ªë l∆∞·ª£ng ph·∫£i t·ª´ 1‚Äì99.", ephemeral: true });
    try {
      await interaction.channel.bulkDelete(count, true);
      return interaction.reply({ content: `üßπ ƒê√£ x√≥a ${count} tin nh·∫Øn!`, ephemeral: true });
    } catch (err) {
      console.error("bulkDelete error:", err);
      return interaction.reply({ content: "‚ùå Kh√¥ng th·ªÉ x√≥a tin nh·∫Øn (c√≥ th·ªÉ v√¨ tin nh·∫Øn qu√° c≈©).", ephemeral: true });
    }
  }

  // activity subcommands (admin) ‚Äî unchanged
  if (cmd === "activity") {
    if (!hasAdminPermission(interaction)) return interaction.reply({ content: "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn.", ephemeral: true });
    const sub = interaction.options.getSubcommand(false);
    if (sub === "setup") {
      const ch = interaction.options.getChannel("channel");
      activityConfig[interaction.guildId] = activityConfig[interaction.guildId] || {};
      activityConfig[interaction.guildId].channelId = ch.id;
      saveActivityConfig();
      return interaction.reply({ content: `‚úÖ ƒê√£ ƒë·∫∑t k√™nh log th√†nh <#${ch.id}>`, ephemeral: true });
    } else if (sub === "enable") {
      activityConfig[interaction.guildId] = activityConfig[interaction.guildId] || {};
      activityConfig[interaction.guildId].enabled = true;
      saveActivityConfig();
      return interaction.reply({ content: "‚úÖ ƒê√£ b·∫≠t log ho·∫°t ƒë·ªông.", ephemeral: true });
    } else if (sub === "disable") {
      activityConfig[interaction.guildId] = activityConfig[interaction.guildId] || {};
      activityConfig[interaction.guildId].enabled = false;
      saveActivityConfig();
      return interaction.reply({ content: "‚úÖ ƒê√£ t·∫Øt log ho·∫°t ƒë·ªông.", ephemeral: true });
    } else {
      return interaction.reply({ content: "‚ùì Subcommand kh√¥ng h·ª£p l·ªá.", ephemeral: true });
    }
  }

  // updated help: include music
  if (cmd === "help") {
    const helpEmbed = new EmbedBuilder()
      .setColor(MAIN_COLOR)
      .setTitle("üìö Danh s√°ch l·ªánh c·ªßa Meyia")
      .setDescription("C√°c l·ªánh hi·ªán c√≥:")
      .addFields(
        { name: "üé∂ Music (slash)", value: "/play, /stop, /skip, /pause, /resume, /queue, /volume", inline: false },
        { name: "üîß Ti·ªán √≠ch", value: "/ping, /info, /avatar, /say, /xoachat", inline: false },
        { name: "üéâ S·ª± ki·ªán", value: "/giveaway", inline: false },
        { name: "üìù Log ho·∫°t ƒë·ªông (Admin)", value: "/activity", inline: false }
      );
    return interaction.reply({ embeds: [helpEmbed], ephemeral: true });
  }

  if (cmd === "status") {
    const uptimeSeconds = Math.floor(client.uptime / 1000) || 0;
    const hours = Math.floor(uptimeSeconds / 3600);
    const minutes = Math.floor((uptimeSeconds % 3600) / 60);
    const seconds = uptimeSeconds % 60;
    const uptimeStr = `${hours}h ${minutes}m ${seconds}s`;

    const embed = new EmbedBuilder()
      .setColor(MAIN_COLOR)
      .setTitle("üíó Tr·∫°ng th√°i bot")
      .addFields(
        { name: "Ping", value: `${client.ws.ping}ms`, inline: true },
        { name: "Servers", value: `${client.guilds.cache.size}`, inline: true },
        { name: "Uptime", value: uptimeStr, inline: true }
      );
    return interaction.reply({ embeds: [embed], ephemeral: true });
  }

  if (cmd === "info") {
    const embed = new EmbedBuilder()
      .setColor(MAIN_COLOR)
      .setTitle("üå∏ Meyia ‚Äî All-in-one bot")
      .setDescription("M·ªôt c√¥ tr·ª£ l√Ω nh·ªè xinh gi√∫p b·∫°n qu·∫£n l√Ω server & mang l·∫°i ni·ªÅm vui üíï")
      .addFields(
        { name: "Developer", value: `<@${OWNER_ID}>`, inline: true },
        { name: "Version", value: "v1.5.1", inline: true },
        { name: "Framework", value: "discord.js v14", inline: true }
      )
      .setFooter({ text: "üíñ Meyia Bot ¬© 2025" });
    return interaction.reply({ embeds: [embed], ephemeral: true });
  }

  // Unknown command fallback
  return interaction.reply({ content: "‚ùì L·ªánh ch∆∞a ƒë∆∞·ª£c tri·ªÉn khai.", ephemeral: true });
});
// ---------- MESSAGE PREFIX COMMANDS ---------- //
client.on("messageCreate", async (message) => {
  if (message.author.bot) return;

  const prefix = "!";
  if (!message.content.startsWith(prefix)) return;

  const args = message.content.slice(prefix.length).trim().split(/ +/);
  const cmd = args.shift().toLowerCase();

  const memberVoice = message.member?.voice?.channel;

  // ---------- !play auto ----------
  if (cmd === "play" && args[0] === "auto") {
    if (!memberVoice) return message.reply("‚ùó B·∫°n ph·∫£i v√†o k√™nh tho·∫°i tr∆∞·ªõc!");

    // T·∫°o queue
    const queue = await client.player.createQueue(message.guild, {
      metadata: { channel: message.channel },
      leaveOnEnd: true,
      leaveOnStop: true,
      leaveOnEmpty: true
    });

    try {
      if (!queue.connection) await queue.connect(memberVoice);
    } catch {
      client.player.deleteQueue(message.guild.id);
      return message.reply("‚ö†Ô∏è Bot kh√¥ng th·ªÉ v√†o voice.");
    }

    // Search random b√†i h√°t (v√≠ d·ª• d√πng 1 s·ªë t·ª´ kh√≥a ph·ªï bi·∫øn)
    const keywords = ["pop", "anime", "gaming", "chill", "lofi", "remix"];
    const randomKeyword = keywords[Math.floor(Math.random() * keywords.length)];

    const search = await client.player.search(randomKeyword, {
      requestedBy: message.author,
      searchEngine: QueryType.AUTO
    });

    if (!search || !search.tracks.length) return message.reply("‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t ng·∫´u nhi√™n!");

    const track = search.tracks[Math.floor(Math.random() * search.tracks.length)];
    queue.addTrack(track);

    if (!queue.playing) await queue.play();

    return message.reply(`üé∂ ƒêang ph√°t b√†i ng·∫´u nhi√™n: **${track.title}**`);
  }

  // ---------- !leave ----------
  if (cmd === "leave") {
    const queue = client.player.getQueue(message.guild.id);
    if (!queue) return message.reply("‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t!");
    queue.destroy();
    return message.reply("‚õî ƒê√£ d·ª´ng nh·∫°c v√† r·ªùi voice.");
  }
});
// === CODE G·ªêC C·ª¶A B·∫†N ===
// ... to√†n b·ªô code index.js b·∫°n ƒë√£ g·ª≠i t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi ...
// (kh√¥ng x√≥a, kh√¥ng s·ª≠a, gi·ªØ nguy√™n t·∫•t c·∫£)

/* =====================================================================
   PH·∫¶N C·∫¢I TI·∫æN TH√äM
   - Auto reconnect voice khi disconnect
   - Th√¥ng b√°o khi queue k·∫øt th√∫c
   - L·ªánh !skipto <s·ªë> cho prefix
   - L∆∞u volume ri√™ng cho t·ª´ng guild
   - Mini log slash command khi bot ready
===================================================================== */

const volumePath = path.join(__dirname, "config", "volume.json");
// ensure config dir exists and create file if missing; safe-read JSON
if (!fs.existsSync(path.dirname(volumePath))) fs.mkdirSync(path.dirname(volumePath), { recursive: true });
if (!fs.existsSync(volumePath)) fs.writeFileSync(volumePath, "{}");
let volumeConfig = {};
try {
  const raw = fs.readFileSync(volumePath, "utf8") || "{}";
  volumeConfig = JSON.parse(raw);
} catch (e) {
  console.warn("‚ö†Ô∏è volume.json parse error, resetting to {}:", e);
  volumeConfig = {};
  fs.writeFileSync(volumePath, "{}");
}

// Auto reconnect voice khi connection error
client.player.on("connectionError", (queue, error) => {
  console.warn(`‚ö†Ô∏è L·ªói k·∫øt n·ªëi voice ·ªü guild ${queue.guild.id}:`, error);
  setTimeout(async () => {
    if (!queue.connection) {
      try { await queue.connect(queue.voiceChannel); } catch(e){ console.error("Reconnect failed:", e); }
    }
  }, 5000);
});

// Th√¥ng b√°o khi queue k·∫øt th√∫c
client.player.on("queueEnd", (queue) => {
  if (queue.metadata?.channel) {
    queue.metadata.channel.send("üì≠ Queue ƒë√£ k·∫øt th√∫c. C·∫£m ∆°n b·∫°n ƒë√£ nghe nh·∫°c!").catch(() => {});
  }
});

// T·ª± ƒë·ªông set volume khi queue ƒë∆∞·ª£c t·∫°o
client.player.on("queueCreate", (queue) => {
  const vol = volumeConfig[queue.guild.id] || 100;
  queue.setVolume(vol);
});

// Log t·∫•t c·∫£ slash command khi bot ready
client.once(Events.ClientReady, () => {
  client.application.commands.cache.forEach(cmd => {
    console.log(`Slash command loaded: /${cmd.name}`);
  });
});

// Prefix command: !skipto <s·ªë>
client.on("messageCreate", async (message) => {
  if (message.author.bot) return;
  const prefix = "!";
  if (!message.content.startsWith(prefix)) return;

  const args = message.content.slice(prefix.length).trim().split(/ +/);
  const cmd = args.shift().toLowerCase();

  if (cmd === "skipto") {
    const queue = client.player.getQueue(message.guild.id);
    if (!queue || !queue.playing) return message.reply("‚ùå Kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t!");
    const num = parseInt(args[0]);
    if (isNaN(num) || num < 1 || num > queue.tracks.length) return message.reply("‚ö†Ô∏è Nh·∫≠p s·ªë h·ª£p l·ªá trong queue!");
    queue.skipTo(num - 1);
    return message.reply(`‚è≠Ô∏è B·ªè qua ƒë·∫øn b√†i s·ªë **${num}**: ${queue.current.title}`);
  }
});

// L∆∞u volume khi d√πng /volume
client.on(Events.InteractionCreate, async (interaction) => {
  if (!interaction.isChatInputCommand()) return;
  if (interaction.commandName === "volume") {
    const value = interaction.options.getInteger("value");
    volumeConfig[interaction.guild.id] = value;
    fs.writeFileSync(volumePath, JSON.stringify(volumeConfig, null, 2));
  }
});
// -------- LOGIN -------- //
const token = process.env.TOKEN || process.env.DISCORD_TOKEN;
if (!token) {
  console.error("‚ùå Thi·∫øu TOKEN trong .env");
  process.exit(1);
} else {
  client.login(token).catch(err => {
    console.error("Login error:", err);
    process.exit(1);
  });
}
